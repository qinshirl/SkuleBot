## Page 1

University of Toronto
Faculty of Applied Science and Engineering
Midterm Test
March 9, 2023
ECE243 – Computer Organization
Examiners – Prof. Stephen Brown and Prof. Jonathan Rose
1. There are 5 questions and 22 pages. Do all questions. The test duration is 105 minutes (1:45 hours).
2. ALL WORK IS TO BE DONE ON THESE SHEETS. You can use the blank pages included on
Pages 16 −18 if you need more space for any question. Be sure to indicate clearly if your work
continues elsewhere.
3. Closed book. Aid Sheets are included for your reference starting on Page 20. We suggest that you
detach the last 2 physical pages (pages 19-22). Page 19 is for use in question 5, but does not need to
be handed in.
4. No calculators are permitted.
Page 1 of 22


## Page 2

1. Short answers:
[11 marks]
(a) Consider the sequence of ARM instructions shown below. Fill in the comment ﬁeld to the right
[8 marks]
of each instruction to show the contents of the destination register after the instruction on that
line of code has been executed. Show your answers in hexadecimal.
.global
_start
_start: LDR
R0, =DATA
MOV
R10, R0
LDR
R1, [R0]
// R1 = ______________
LDR
R2, [R0, #8]
// R2 = ______________
LDR
R3, [R0, #4]!
// R3 = ______________
LDR
R4, [R0], #4
// R4 = ______________
LDRB
R5, [R10, #3]
// R5 = ______________
LDRB
R6, [R10, #0xC]
// R6 = ______________
MOV
R7, #0xFF
// R7 = ______________
STRB
R7, [R10]
LDR
R8, [R10]
// R8 = ______________
END:
B
END
DATA:
.word
0x11110000
.word
0x22221111
.word
0x33332222
.word
0x44443333
Page 2 of 22


## Page 3

(b) In Lab Exercise 4, the ARM instruction that you used to return from an interrupt is
[3 marks]
SUBS
PC, LR, #4
Answer the following question. Instead of using the above SUBS instruction, could you instead
return from an interrupt using the following sequence of instructions? That is, would these
instructions have exactly the same effect? Explain your answer.
SUBS
LR, #4
MOV
PC, LR
Answer
Page 3 of 22


## Page 4

2. Short coding:
[8 marks]
(a) The ARM code below loads into R0 the number at address X and then calls the subroutine
[4 marks]
named LOG2. The number X could be any positive integer > 0 that is a power of 2. The LOG2
subroutine is supposed to return in register R0 the base 2 logarithm, log2 X. Write the LOG2
subroutine in the space provided below.
.global
_start
_start:
LDR
SP, =0x20000
LDR
R0, =X
LDR
R0, [R0]
BL
LOG2
END:
B
END
LOG2:
X:
.word
64
// example data
Page 4 of 22


## Page 5

(b) The ARM code below loads into R0 and R1 the two numbers at addresses X and Y, respectively.
[4 marks]
The code then calls the subroutine named MASK. The number X could be any positive integer
> 0 and Y can be any integer from 1 to 32. The MASK subroutine is supposed to return in register
R0 the Y least-signiﬁcant bits of X. Write the MASK subroutine in the space provided below. For
the example given in the code, where X = 0x63 and Y = 4, the MASK subroutine should return
the result 3.
.global
_start
_start:
LDR
SP, =0x20000
LDR
R0, =X
LDR
R1, [R0, #4]
// load Y
LDR
R0, [R0]
// load X
BL
MASK
END:
B
END
MASK:
X:
.word
0x63
Y:
.word
4
Page 5 of 22


## Page 6

3. Consider the C code shown below.
[15 marks]
int rand (int, int);
volatile int *Timer_ptr = (int *) 0xFFFEC600;
volatile int *LEDR_ptr = (int *) 0xFF200000;
volatile int *KEY_ptr = (int *) 0xFF200050;
int main()
{
int press, value;
*Timer_ptr = 200000000;
*(Timer_ptr + 2) = 3;
while (1) {
press = *(KEY_ptr + 3);
if (press) {
value = rand (press, 100);
*LEDR_ptr = value;
*(KEY_ptr + 3) = press;
}
}
}
int rand(int even, int range){
int local;
local = *(Timer_ptr + 1);
local = local % range;
if (even == 1) local = local & 0xFE;
else local = local | 1;
return local;
}
(a) The ARM A9 Private Timer is used in this program. How long (in seconds) does it take the
[1 mark]
timer to count down to zero?
Answer
Page 6 of 22


## Page 7

(b) Explain, brieﬂy, what this program “does.” That is, if you were to execute this program, using
[4 marks]
the CPUlator or on a DE1-SoC board, what would the program display on the LEDR port?
Answer
(c) In this part you are to translate only the main function from the C program into ARM assembly
[5 marks]
language code. You are given part of the solution on the following page. Fill in the rest of the
code. Make sure to follow the ARM Procedure Call Standard (PCS) in your code. For calling the
rand() subroutine (which you will be translating in part (d) of this question), pass the press
argument in register R0, and pass the constant 100 argument in register R1. Make your assembly
code as simple as possible, and provide comments that help to illustrate how your assembly code
corresponds to the orginal C code.
Put your answer on the next page.
Page 7 of 22


## Page 8

.global _start
_start:
MAIN:
LDR
SP, =0x20000
LDR
R12, =0xFFFEC600
LDR
R0, =200000000
STR
R0, [R12]
MOV
R0, #0b011
STR
R0, [R12, #0x8]
LDR
R4, =0xFF200000
WHILE:
LDR
R0, [R4, #0x5C]
// R0 = press (EdgeCapture)
Page 8 of 22


## Page 9

(d) In the space below, write assembly code for the rand() subroutine. Its even parameter is
[5 marks]
passed in R0, and its range parameter in R1. To implement the C modulus operator % the
RAND subroutine should call the MOD subroutine that is provided at the bottom of this page.
// parameters are in R0, R1
RAND:
// returns the modulus R0 = R0 % R1
MOD:
CMP
R0, R1
// n - i < 0?
BLT
ENDM
SUB
R0, R1
// n = n - i
B
MOD
ENDM:
MOV
PC, LR
// modulus is in R0
Page 9 of 22


## Page 10

4. As part of Lab Exercise 2 in this course the you were asked to write a program to ﬁnd the largest
[12 marks]
sequence of 1’s in a list of data words. An attempted solution to this problem is given below. In this
solution (although not done in the Lab 2 version) the ﬁnal answer is displayed on the LEDR lights.
1
.global _start
2
_start:
3
LDR
R4, =TEST_NUM
4
LDR
R6, =0xFF200000
5
MOV
R5, #0
// R5 will hold the result
6
MAIN_LOOP:
LDR
R0, [R4]
7
CMP
R0, #0
// done ?
8
BEQ
END_ONES
9
BL
ONES
10
CMP
R5, R1
11
MOVLT
R5, R1
12
ADD
R4, #4
13
STR
R5, [R6, #0x20]
14
B
MAIN_LOOP
15
END:
B
END
16
17
ONES:
MOV
R1, R0
18
MOV
R0, #0
19
LOOP:
CMP
R1, #0
20
BEQ
END_ONES
21
LSR
R2, R0, #1
22
AND
R1, R1, R2
23
ADD
R0, #1
24
B
ONES
25
END_ONES:
MOV
PC, LR
26
27
TEST_NUM:
.word
0x103fe00f
// the data
28
.word
0x3fabedef
29
.word
0x00000001
30
.word
0x75a5a5a5
31
.word
0x01ffC000
32
.word
0x03ffC000
33
.word
0x11111111
34
.word
0
// end of data
35
36
.end
The above program contains a number of logical errors. In the space on the following page, provide
Page 10 of 22


## Page 11

a corrected version of the code. You can either show all of the code, or else show only the lines of
code that you corrected. Either way, indicate clearly where you have made changes to the code, for
example by using the line numbers shown in the code, or encircling/underlining your corrections. Do
not add any additional lines of code to ﬁx the errors; just correct the errors in the code that is there.
There are no errors in lines 1 to 5, or 27 to 36.
PROVIDE YOUR CORRECTED CODE IN THE SPACE BELOW:
Page 11 of 22


## Page 12

5. As part of Lab Exercise 5 in this course the you were asked to write a program that draws an animation
[11 marks]
on the VGA screen. In this question you are asked to write a similar program, making an animation
with a number of square boxes that “move” vertically up and down on the screen. In the same way
that you did for Lab 5, you are to use double-buffering for your animation. Some parts of the required
C code are provided for you, starting on the next page and on Page 19. You are to ﬁll in the missing
lines of code.
Your code should use the subroutines in the code provided on Page 19, just before the Aid Sheets.
The provided subroutines are called init boxes(), clear screen(), plot pixel() and
wait for vsync(). You are encouraged to detach Pages 19 to 22 of the test, for ease of reference.
Keep these pages after the test (you should not hand them in).
Your animation involves 12 square boxes. The main program ﬁrst ﬁnds random locations for each of
these boxes, using the provided subroutine init boxes() on Page 19. This subroutine also sets a
variable dy box for each box to either -1 or 1, which causes each box in the animation to move up or
down on the screen. Also, a random color from the set red, green, or blue, is set for each box.
Next, the main program has to set up the DMA controller so that it uses two pixel buffers. Part of
this code is provided on the next page, but you need to write additional code (indicated in the partial
solution with the comment // finish DMA setup in the space below ...) to com-
plete the setup of the DMA controller. Note that the code for the clear screen() subroutine is
provided for you, as is the code for the plot pixel() subroutine on Page 19.
The main part of the animation is in the while loop. The ﬁrst few lines of code in this loop are
provided for you. This code calls a function draw box(), to draw each box on the pixel buffer. You
will write the code for draw box() in part (c) of this question.
Write the rest of the required code for the animation in the while loop that makes the boxes appear
to move vertically up and down on the VGA screen. Be sure to check for edge conditions, so that
boxes appear to “bounce” off the bottom and top of the screen (like you did for your animations in
Lab 5). Also, be sure to synchronous each frame of your animation with the DMA controller using
wait for vsync(). The code for wait for vsync() is provided for you (on Page 19).
The C code for the required solution starts on the next page.
Page 12 of 22


## Page 13

(a) Fill in your code for setting up the DMA in the space a t the bottom of this page.
[3 marks]
#include <stdlib.h>
// needed for rand()
/* subroutine prototypes */
void init_boxes(void);
void clear_screen(void);
void draw_box(int, int, short int);
void plot_pixel(int, int, short int);
void wait_for_vsync(void);
#define NUM_BOXES 12
// number of boxes in the animation
#define SIZE_BOX 8
// width & height of each box in pixels
int x_box[NUM_BOXES], y_box[NUM_BOXES];
// box (x, y)
int dy_box[NUM_BOXES];
// box delta-y
int color_box[NUM_BOXES];
// box color
unsigned int color[] = {0xF800, 0x07E0, 0x001F};
// colors
int pixel_buffer_start; // specifies which memory is currently
// being used as the back buffer.
int main(void)
{
int i;
volatile int * pixel_ctrl_ptr = (int *) 0xFF203020; // DMA
init_boxes();
*(pixel_ctrl_ptr + 1) = 0xC8000000;
pixel_buffer_start = *(pixel_ctrl_ptr + 1);
clear_screen();
// finish DMA setup in the space below ...
Page 13 of 22


## Page 14

(b) The C code for main program continues below. Fill in the missing code.
[5 marks]
while (1) {
clear_screen(); // erase previous animation frame
for (i = 0; i < NUM_BOXES; i++) {
draw_box(x_box[i], y_box[i], color_box[i]);
}
}
// end of while loop
} // end of main
Page 14 of 22


## Page 15

(c) Put your code for the draw boxes() subroutine in the space below. Draw each box as a
[3 marks]
square that is ﬁlled with the box’s color. Each box is SIZE BOX pixels in width and SIZE BOX
pixels in height.
void draw_box(int x0, int y0, short int color) {
} // end of draw_box
Page 15 of 22


## Page 16

Extra answer space for any question on the test, if needed:
Page 16 of 22


## Page 17

Extra answer space for any question on the test, if needed:
Page 17 of 22


## Page 18

Extra answer space for any question on the test, if needed:
Page 18 of 22


## Page 19

These subroutines are provided for you as part of Question 5.
void init_boxes() {
int i;
for (i = 0; i < NUM_BOXES; i++) {
x_box[i]
= (rand() % (320 - SIZE_BOX));
// random x
y_box[i]
= (rand() % (240 - SIZE_BOX));
// random y
dy_box[i] = ((rand() % 2) * 2) - 1;
// 1 or -1
color_box[i] = color[(rand() % 3)];
// random color
}
}
void clear_screen() {
int y, x;
for (x = 0; x < 320; x++)
for (y = 0; y < 240; y++)
plot_pixel (x, y, 0);
}
void plot_pixel(int x, int y, short int color) {
*(short int *)(pixel_buffer_start + (y << 10) + (x << 1)) =
color;
}
void wait_for_vsync() {
volatile int * pixel_ctrl_ptr = (int *) 0xFF203020; // DMA
int status;
*pixel_ctrl_ptr = 1; // start the synchronization process
status = *(pixel_ctrl_ptr + 3);
while ((status & 0x01) != 0)
status = *(pixel_ctrl_ptr + 3);
}
Page 19 of 22


## Page 20

—————————————– Aid Sheet —————————————–
ARM Addressing Modes
Name
Assembler syntax
Address generation
Offset:
immediate offset
[Rn, #offset]
Address = Rn + offset
offset in Rm
[Rn, ±Rm, shift]
Address = Rn ± Rm shifted
Pre-indexed:
immediate offset
[Rn, #offset]!
Address = Rn + offset;
Rn ←address
offset in Rm
[Rn, ±Rm, shift]!
Address = Rn ± Rm shifted;
Rn ←address
Post-indexed:
immediate offset
[Rn], #offset
Address = Rn;
Rn ←Rn + offset
offset in Rm
[Rn], ±Rm, shift
Address = Rn;
Rn ←Rn ± Rm shifted
I/O Ports in the DE1-SoC Computer
Page 20 of 22


## Page 21

Page 21 of 22


## Page 22

Note: OnChip memory starts at address is 0xC8000000, and SDRAM starts at 0xC0000000.
Page 22 of 22

