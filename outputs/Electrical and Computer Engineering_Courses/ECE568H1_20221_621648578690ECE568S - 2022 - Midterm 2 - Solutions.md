## Page 1

ANSWER KEY
ECE568S: Midterm Exam
Examiner: C. Gibson
DURATION: 90 Minutes
1. Please use a pen to complete all of your answers to the midterm.
2. Do not turn this page over until you have received the signal to start.
3. This exam is closed book and closed notes. One 8.5”x11” double-sided aid sheet 
containing your own personally-created notes is permitted. Use of calculators, 
computing and/or communicating devices is not permitted.  Work independently.
4. Do not remove any sheets from this test book.  Answer all questions in the space 
provided, unless otherwise indicated.  No additional sheets are permitted.
5. The value of each question or part-question is noted next to the question.  The 
total of all marks is shown below.
6. Please write your name and student number in the space below, and write your 
name on the top of each sheet.
Name: 
_________________________________
Student Number: 
____________________
Q1. ______ / 22
Q2. ______ / 20
Q3. ______ / 28
 
Total: ______ / 70
ECE568S – 2022 Midterm
Pg. 1 of 11


## Page 2

ANSWER KEY
1.  Short-Answer Questions  (22 marks)
Please briefly answer the following questions, in the space provided.  If you require more space, please 
indicate that you are continuing your answer on the back of the sheet, and put the question number next
to the continuation of your answer.
1)
Briefly explain why each of the following cryptographic protocols do or do not allow for a
message, M, to be exchanged with integrity and non-repudiation:
a)  
Alice and Bob use the Needham-Schroeder key exchange protocol to securely exchange
establish a shared key, k.  Alice uses that key to encrypt a message, M, using AES-256
in CBC mode, before sending the encrypted message to Bob.  [4 marks]
Answer:  No: this does not provide integrity or non-repudation. Encryption alone
doesn’t provide integrity assurace. As for non-repudiation, both Bob and the trusted
server know the secret key; either could simply forge a fake message, M, encrypt it with
the key and claim it came from Alice.  (Or, Alice could later lie and claim that either
Bob or the trusted server faked the message, even if they did not.)
b)
Alice and Bob meet in person and securely exchange a one-time pad.  Later, Alice uses
the one-time pad to encrypt a message, M, before sending the encrypted message to
Bob.  [4 marks]
Answer:  No: this does not provide for integrity or non-repudiation.  Same argument
as above: encryption doesn’t provide integrity, and Bob could simply forge a message
from Alice (or Alice could claim that he did).
c)
Alice sends Bob her X509 public key certificate, which she has self-signed.  Alice
creates a public-key digital signature of the message, M; she then sends both the
plaintext message (M) and the signture to Bob.  [4 marks]
Answer:  This does provide integrity, but does not provide non-repudiation. While
public-key-based signatures generally do provide non-repudiation, in this case Alice has
self-signed her X509 certificate. She could later claim that the private key used to sign
the message isn’t hers (or Bob could simply create a self-signed key that claims to be
Alice’s).
ECE568S – 2022 Midterm
Pg. 2 of 11


## Page 3

ANSWER KEY
2)
Briefly explain a situation in which you might choose to use a self-signed certificate in a
 
product (i.e., not for testing).  [4 marks]
ANSWER:  Several possible answers.  In general, this would be acceptable (and still secure)
if you are the author/operator of the software on both sides of the communication (e.g., if you 
have written both the client application and the associated server).  In this case, you could
easily have your client/server code trust your own private CA.
Some answers were given assuming that the “you” in this question is an operator who is a
legitimate global Certificate Authority.  This was acceptable as well.
3)
You have been asked to build an OTP (One-Time Password) system that needs to meet some
 
unique constraints.  The user can generate a new 6-digit OTP value on-demand (similar to
HOTP), but with two constraints: (1) the generated value can only be used once; and, (2) the 
generated value should automatically expire at the end of the day (i.e., it is no longer
accepted as valid after midnight).  Using what you learned about OTP algorithms in Lab 2,
briefly describe an algorithm that would generate a single 6-digit OTP code that would meet
this requirement.  (Other than a one-time initial setup, no other messages should be exchanged,
other than 6-digit OTP codes.)  [6 marks]
ANSWER:  The basic idea would be to combine HOTP and TOTP.  The server would generate
and distribute an OTP secret through some secure means (e.g., via a QR code).  Similar to
HOTP, a counter value is incremented every time the user requests a new code.  The hash string
should be composed by combining the shared OTP secret, the counter value (similar to HOTP)
and the time of day (similar to TOTP).  Instead of rotating the time value every 30 seconds, the
time value would rotate once a day, at midnight.
ECE568S – 2022 Midterm
Pg. 3 of 11


## Page 4

ANSWER KEY
2.  Input Vulnerabilities  (20 marks)
1)
Explain why NX (Non-Executable Page) protection does or does not prevent the following 
types of attack  (3 x 2 marks)
Buffer Overflow with injected shellcode:
ANSWER: NX does prevent traditional Buffer Overflow attacks, because any shellcode
placed on the stack cannot be executed.
Double-Free with injected shellcode:
ANSWER: NX does prevent traditional Double Free attacks, because any shellcode placed
into the heap cannot be executed.
Return-Oriented Programming:
ANSWER: NX does not prevent ROP – because this technique makes use of code that
legitimately already exists (and is, therefore, already marked as “executable”).
ECE568S – 2022 Midterm
Pg. 4 of 11


## Page 5

ANSWER KEY
2)
Consider the following program with a buffer overflow vulnerability:
1:
void foo(char * buf, char * arg)
2:
{
3:
strncpy(buf, arg, 32);
4:
}
5:
6:
int main(int argc, char * argv[])
7:
{
8:
char string[12];
9:
10:
strncpy(string, argv[1], 12);
11:
foo(string, argv[2]);
12:
return(0);
13:
}
Where is the vulnerability located, which function’s saved Return Address should the attacker 
target, and how would they pass their overflow code into the application?  (5 marks)
ANSWER:  The vulnerability is on line 3: the strncpy will copy up to 32 bytes into the 12-byte
array.  Because string is local to main, the attacker would be targetting main’s return address.
The overflow code would be provided as the second command-line parameter (argv[2]).
A significant number of answers suggested a GOT overwrite and ignored the Return Address
completely (despite the question asking about it); partial marks were provided for this.
ECE568S – 2022 Midterm
Pg. 5 of 11


## Page 6

ANSWER KEY
3)
You have been asked to perform a security audit of one of your company’s applications.  You
discover the following:
1. There is a format string vulnerability that an attacker could exploit.
2. The program’s stack and heap are marked as non-executable (NX), which means that the 
attacker cannot place their shellcode into any of the program’s variables or arrays.
3. However, you discovered a second vulnerability: the application uses dynamic linking to 
load in an external library at runtime.  The library is loaded into memory at a fixed address 
of 0x4000, and the memory it occupies is marked as both writable and executable.
Briefly explain how an attacker could potentially exploit this.  [5 marks]
ANSWER:  The attacker could use the format string vulnerability to: (1) write the bytes of the 
shellcode into memory, starting at address 0x4000 (using the same technique that we discussed 
in class to overwrite the RA value); and, (2) overwrite the Return Address with a value of 
0x4000.
ECE568S – 2022 Midterm
Pg. 6 of 11


## Page 7

ANSWER KEY
4)
Consider a double-free vulnerability, as discussed in class.  The memory manager’s “tag”
structure consists of a previous pointer, followed by some flags, and then a next pointer:
previous
flags
next
In order to test the vulnerability, you create a “fake tag” that points to your shellcode and the 
location of the saved Return Address in the stack:
&shellcode
0
&returnAddress
When the exploit executes, the memory manager will perform the following comands:
(tag->next)->previous = tag->previous;
(tag->previous)->next = tag->next;
Briefly describe the potential problem this creates with your shellcode, and how your shellcode 
should be written to deal with it.  [4 marks]
ANSWER:  The second line (updating the “next” pointer) overwrites some bytes of the 
shellcode with the address of the Return Address.  To adjust for this, the shellcode should 
contain a “jump” command to skip over the bytes that will be overwritten.
ECE568S – 2022 Midterm
Pg. 7 of 11


## Page 8

ANSWER KEY
3.  Cryptography  (28 marks)
1)
Alice wishes to send a message, M, to Bob. They have previously exchanged a key, k.  They
both have agreed on a block cipher, Ek, with CBC for their encryption mode, and also a hash
function, H.  The IV (Initialization Vector) is set equal to the current time of day. (You can
assume that their key exchange protocol, the block cipher and their hashing function are all
secure, and their clocks are synchronized.)
Now, suppose that Alice transmits a message, M, to Bob as follows:
{ Ek(M), H(M) }
a)  Explain why this protocol does or does not provide message integrity protection.  (4 marks)
ANSWER:  Yes, it does.  If the cryptotext is altered, the receiver could detect it, as their
calculated H(M) will not match the one sent with the message.  An attacker could not forge
an H(M) without knowing how their altered cryptotext would decrypt – which would require
knowing the key, k.
b)  Explain why this protocol does or does not provide replay protection against an attacker
who might try to re-transmit the same message minutes or hours later.  (4 marks)
ANSWER:  Yes, it does. The receiver will use the current time as the IV while decrypting;
if this is a replay of an old message, then the cryptotext will decrypt incorrectly – and the
resulting plaintext will not match H(M).
This question was somewhat ambiguous: some people took “current time” as I had intended
it (something similar to a Unix timestamp), while others took it to mean something like
“1:06pm”, which would repeat every day.  If you assume that the time is not unique then
it provides short term protection (minutes later), but not long-term protection (you could
repeat a message every 24 hours).
ECE568S – 2022 Midterm
Pg. 8 of 11


## Page 9

ANSWER KEY
Continued from above...
c) The encryption is done using CBC as an encryption mode. Given this protocol, is this
sufficient to prevent an attacker from spotting patterns of repeated messages?  (Briefly explain
your answer.)  (4 marks)
ANSWER:  It is not.  The primary reason is that “H(M)” will be the same for any given
message “M”; an attacker could easily identify repeated messages, as they will hash to the
same value.  (Additionally, if messages are repeated very quickly, they might be sent with
the same IV – which would result in identical cryptotext as well.)
Many answers considered only this one piece of information (CBC mode), rather than the
overall messaging protocol between Alice and Bob.
2)
You are asked to evaluate a proposed change to the Needham-Schroeder key-exchange protocol.
The proposal is to speed up the exchange by elminating the last two “nonce” messages.  The
third message will be extended to be:
{(KAB, A)}KB    +  {KAB}KAB
By sending KAB  encrypted with itself, A is attempting to convince B of two things: (1) that
A truly knows the key KAB (and therefore is not an imposter); and, (2) A is actively encrypting
the current value of KAB (and therefore this is not a replay).
 Explain whether the proposed changes are meeting their stated goals, and whether the
Needham-Schroeder protocol would still be as secure.  (4 marks)
ANSWER:  No, it would not be as secure.  An attacker could simply replay this modified
message #3 to B at some later date – and B would be unable to tell if it was a live message
or a replay.
ECE568S – 2022 Midterm
Pg. 9 of 11


## Page 10

ANSWER KEY
3)
Assume that Alice has an X509 certificate that is signed by a CA that Bob trusts.  Alice and
Bob have never communicated before.  Briefly explain: (1) the steps that Alice would take to
create a public-key digital signature for a message, M; (2) what Alice would need to send to
Bob; and, (3) the steps that Bob would validate the signature.  [6 marks]
ANSWER:
1) Alice would hash the message and then encrypt the hash with her private key.
2) Alice would send Bob her X509 certificate, the message, and the signature (encrypted hash).
3) Bob would:
(a) validate the X509 certificate (and extract the public key from it);
(b) calculate the hash of the message himself;
(c) decrypt Alice’s signature using her public key, and compare it to his calculated hash.
Note: many people included a step where Bob communicates directly with the Certificate
Authority – either to obtain Alice’s X509 certificate, to validate the signature on Alice’s cert,
to ask if Alice was really sending a message, etc..  Certificates are designed to ensure that
none of those steps are required.  (The only notable exception would be a call to check if a
revocation certificate has been issued – but that is different than checking if the initial cert
is valid.)
ECE568S – 2022 Midterm
Pg. 10 of 11


## Page 11

ANSWER KEY
4)
When your phone receives a call, the “caller ID” data is sent just after the first ring, as a short
message that contains the date, time and phone number of the person calling you.  The callerID
data is typically a 20-byte message; for example:
0x04
0x12
“0317”
“1015”
“4165551212”
Caller ID Data
0x12 more bytes... March 17th
10:15am
Caller is (416) 555-1212
Originally, the callerID protocol was designed with the assumption that everyone could be 
trusted to truthfully report their telephone number; as a result, the protocol has no built-in 
protections. Unfortunately, VoIP (Voice Over IP) services now make it trivial for anyone to 
“spoof” (fake) their callerID – which had led to an explosion of telephone scams over the past 
few years.
You are asked to design a secure replacement protocol, that will “fix” callerID.  You may 
assume that all legitimate callers are issued a trusted X509 certificate that identifies them as 
the legitimate owner of the number.  Explain how you would design a replacement callerID 
message, so that someone receiving the message could fully trust that it was legitimate.  (If you 
are encrypting/hashing/signing any data, please clearly indicate the specific data that you are 
processing.)  [6 marks]
ANSWER:  There are many possible answers, but a correct one needs to provide message 
integrity and message authentication.  The easiest solution is likely:
(1) the caller needs to know that they are the intended recipient, so the number being called 
should be included;
(2) the caller should sign the entire message (date/time/caller’s number/callee’s number);
(3) the caller should include their X509 cert (or the callee should be able to ask for it... or it 
should be published to some central “phone book” database that the callee can retrieve it from)
ECE568S – 2022 Midterm
Pg. 11 of 11

