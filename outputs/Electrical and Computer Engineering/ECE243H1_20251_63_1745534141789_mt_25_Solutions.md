## Page 1

![Page 1](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_001.png)

University of Toronto
Faculty of Applied Science and Engineering
Midterm Test: ECE243 – Computer Organization
March 5, 2025
6:15pm - 8pm
Examiners – Andreas Moshovos and Jonathan Rose
SOLUTIONS
1. There are 5 questions and 21 pages. Do all questions. Each question indicates how many marks are
available for it.
2. The test duration is 105 minutes (1 hour and 45 minutes).
3. ALL WORK IS TO BE DONE ON THESE SHEETS. You can use the blank pages included on
Pages 19-21 if you need more space for any question. Be sure to indicate clearly if your work contin-
ues on those pages.
4. Closed book. Each question contains any necessary details you’ll need, except that the Nios V Calling
Convention is given on page 18.
5. No calculators are permitted.
Page 1 of 21


## Page 2

![Page 2](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_002.png)

1. Short Answer Questions. Give your written answers in the space provided.
[15 marks]
(a) What is the difference between a Nios V jump instruction (e.g. j label where label the
[3 marks]
label of another instruction) and a call instruction (e.g. call label)? In your answer be sure
to give detail about what each instruction does.
SOLUTION:
The jump instruction transfers control/execution to the address of the instruction at the label.
The effect of the instruction is to change the program counter to be the address of the label.
The call instruction does everything the jump instruction does, but prior to changing the program
counter it copies the program counter into the register ra register. This is because call is for
invoking a subroutine, which must return to the address following the call instruction once the
routine is finished, using the ret instruction.
(b) Explain why the stack needs to have the Last-In-First-Out (LIFO) property, in relation to calling
[2 marks]
subroutines, transmitting parameters and saving registers.
SOLUTION:
The LIFO ordering is necessary because subroutines are executed in LIFO order: the last sub-
routine called is the first one to be returned from, and so data that is stored associated with the
each subroutine must also come and go in the same order.
Page 2 of 21


## Page 3

![Page 3](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_003.png)

(c) When you arrive in the lab (in the Bahen building) for this course and begin to test your work,
[2 marks]
explain what needs to happen to make the DE1-SoC board into the DE1-SoC Computer System
that you used in the lab. The DE1-SoC Computer System contains a Nios V processor and In-
put/Output devices.
SOLUTION:
The FPGA on the DE1-SoC board needs to be programmed to become the digital hardware that
is the Nios V processor (and the surrounding logic that implements the input/output devices - not
required) and DE1-SoC. This is done by getting the monitor program to download the system, or
with command line process released part-way through the term, the related makefile commands.
(d) What is CPULATOR? Also, name one thing that CPULATOR cannot do that the DE1-SoC
[2 marks]
Computer System hardware can do.
SOLUTION:
CPULATOR is a simulation of a the DE1-SoC hardware that runs on regular computer in a web
browser. It both compiles/assembles programs for the Nios V and simulates the execution of the
program inside the ’other’ computer. Can’t do: take input from a microphone (per lab 6) OR
can’t it run as fast as the real hardware. (Other answers may also be acceptable)
Page 3 of 21


## Page 4

![Page 4](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_004.png)

(e) Why is the subroutine calling convention (such as the Nios V calling convention given on page
[3 marks]
18) necessary? Do not simply restate the convention, but explain what problem it is solving.
SOLUTION:
A calling convention makes it possible for assembly language programs that are not written by
the same person/compiler to work correctly, because it dictates which registers can be used in
callee and caller code without need to save, which ones do need to be saved, and exactly how
information must be transmitted between the caller and callee. Without agreement between all
such software that interacts, the software wouldn’t function - the information wouldn’t be trans-
mitted, and registers that contained information for functionality would be over-written.
(f) If there was no interrupt mechanism in a processor, but the computer system that contained the
[3 marks]
processor had ten separate I/O devices that were necessary to interact with, what would the soft-
ware in the system need to do to have the equivalent functionality provided by interrupts?
SOLUTION:
You’d need a polling loop that was executed reasonably often that individually polled each of the
ten devices and responded to call the equivalent of an Interrupt Service Routine for each device
when its polling status indicated that it needed service.
Page 4 of 21


## Page 5

![Page 5](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_005.png)

2. Memory:
[15 marks]
(a) Consider the following NIOS V code sequence of assembly directives:
[7 marks]
.equ SOMETHING, 15
one:
.hword 12
.hword 0b1111111100000000 # eight 1s and eight 0s
two:
.word -1, 0x87654321, three
three:
.hword 0x1234, 10
four:
.byte SOMETHING+2, 12, 0x80, -2
Assume that the assembler places the above data starting at address 0x1000. You are to fill in
the table below with the memory values that the above directives generate. Each cell in the table
corresponds to a single byte in memory. You must use hexadecimal values in the table. Any memory
contents that are not defined by the above statements should be marked with “U”.
values/contents
ADDRESS
+0
+1
+2
+3
0x1000
0x0c
0x00
0x00
0xFF
0x1004
0xff
0xff
0xff
0xff
0x1008
0x21
0x43
0x65
0x87
0x100c
0x10
0x10
0x00
0x00
0x1010
0x34
0x12
0x0a
0x00
0x1014
0x11
0x0c
0x80
0xFE
0x1018
U
U
U
U
Page 5 of 21


## Page 6

![Page 6](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_006.png)

(b) Assume that each byte in a NIOS V processor’s memory contains the values as given in the
[4]
following table:
values/contents
ADDRESS
+0
+1
+2
+3
0x101C
0x01
0x02
0x03
0x04
0x1020
0x05
0x06
0x07
0x08
0x1024
0x11
0x22
0x33
0x44
0x1028
0x55
0x66
0x77
0x88
0x102C
0x99
0xaa
0xbb
0xcc
0x1030
0xdd
0xee
0xff
0x00
Consider the sequence of NIOS V instructions in the following. Fill in the comment field on the
right of each instruction to show the contents of the given register after the instruction on that line
of code has been executed. To be clear, the register shown in the comment is the one you are giving
the contents for if the instruction executes successfully. Give your answers in hexadecimal, or if the
instruction does not execute successfully, explain why it does not. Assume that a0=0x1027.
SOLUTION:
.text
start:
lb
s0, 0(a0) // s0 = 0x000 00044
lh
s0, 3(a0) // s0 = 0xFFFF 8877___
lw s0, -7(a0) // s0 = 0x08070605____
sw s0, 1(a0) //
lw s0, 2(a0) // s0 = __misaligned access_______
(c) The ‘sw’ instruction of part (b) overwrites 4 bytes in memory. In the table below, fill in in hexadeci-
[2 Marks]
mal the starting address of those four bytes and their final values. The leftmost cell is the word-aligned
address, and the other cells represent a byte in memory at the given offsets.
SOLUTION:
ADDRESS
+0
+1
+2
+3
0x1028
0x05
0x06
0x07
0x08
(d) When the first three instructions of part (b) execute, how many bytes would have been read from
[2 Marks]
memory in total? Include all accesses that the processor perform during their execution whether they
Page 6 of 21


## Page 7

![Page 7](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_007.png)

are for instructions or data. SOLUTION:
Bytes Read from Memory = 3 x 4 (fetches) + 1 (lb) + 2 (lh) + 4 (lw) = 19B
Page 7 of 21


## Page 8

![Page 8](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_008.png)

3. For each of the following C-language code fragments, translate the code as directly as possible into
[15 marks]
Nios V Assembly statements and directives.
(a) For the following C-Code, you must use a register for the variable i (i.e. don’t use a memory
[4 marks]
location):
int X[10];
for (int i = 0; i < 10; i++)
X[i] = i;
SOLUTION:
_start: li t0, 0
#int i = 0
li t1, 10
# for comparing loop cond
la t2, X
# first element of array’s address
loop: sw t0, (t2)
# main store into array
addi t0, t0,1
# increment i
addi t2,t2,4
# increment array pointer
blt t0, t1, loop # end of loop condition
done: j done
# NOT REQUIRED
X: .word 0,0,0,0,0,0,0,0,0,0
Page 8 of 21


## Page 9

![Page 9](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_009.png)

(b) For code below, be sure to use the Nios V calling convention, given on page 18 of this test.
[6 marks]
int main (void) {
int x,y,z;
x = foo(2);
y = foo(3);
z = x + y;
}
int foo (int a) {
return (a+a+a);
}
SOLUTION:
_start: la s0, x
# start not required
li a0,2
call foo
sw a0,(s0)
li a0,3
call foo
sw a0,4(s0)
lw t0,(s0)
add t0,t0,a0
sw t0,8(s0)
done: j done
foo: mv t0,a0
add a0, a0, a0
add a0, a0, t0
ret
x: .word 0
y: .word 0
z: .word 0
Page 9 of 21


## Page 10

![Page 10](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_010.png)

(c) Convert the following C Code into assembly language statements that perform each statement
[5 marks]
as given. You are required to place the variables x, y and p into memory - i.e. they may not
only be in registers. Recall that ‘*’ in C means to dereference a pointer, whereas ‘&’ returns a
pointer to a variable.
int x = 36;
int y;
int *p;
p = &x;
y = *p + 5;
SOLUTION:
# get the addresses of all three variables
la t0, x
# address of x into t0
la t1, y
# address of y into t1
la t2, p
# address of p into t2
sw t0, (t2)
# p = & x;
lw t3, (t0)
# get value of x into register
addi t3,t3,5
# adding 5 to value of x
sw t3,(t1)
# store result (x+5) into y
x: .word 36
y: .word 0
p: .word 0
Page 10 of 21


## Page 11

![Page 11](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_011.png)

4. The Nios V Assembly language program given on the next page is supposed to have the following
[15 marks]
functionality: It uses the interval timer to change the 10 LEDs on the DE1-SoC board every 0.25
seconds, such that the “LED Sequence” shown below appears on the LEDs. To be clear, at the start
the LEDs should look like line 1 of the sequence, and then 0.25 seconds later they should look like
line 2, and so on. Once line 5 is displayed, the next line should be line 1 again.
The diagram on the right below shows the addresses and functions of the registers associated with the
Interval Timer, the same as you used in Lab 4. Recall also that the Interval Timer is clocked with a
frequency of 100MHz.
The program on the following page that is supposed to have the above functionality, actually has
5 errors in it. The errors are either syntax errors or errors that will lead to incorrect functionality.
Identify each error (directly on the page) and give the what the single correct line should be. Give
your answers - the five correct lines - directly on the next page.
Page 11 of 21


## Page 12

![Page 12](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_012.png)

SOLUTION:
.global _start
.equ
TIMER_BASE, 0xFF202000
.equ
COUNTER_DELAY, 30000000
# should be 25000000
.equ
LEDs, 0xff200000
_start: la
t5, TIMER_BASE
sw
zero,0(t5)
li
t0,COUNTER_DELAY
sw
t0,0x8(t5)
slli
t1,t0,16
# should be srli t1,t0, 16
sw
t1,0xc(t5)
li
t0,0b1100
# should be: li t0, 0b0110
sw
t0,0x4(t5)
li
t2,16
la
t3,patterns
la
t4,LEDs
tloop:
add
t6,t3,t2
lw
s0,(t6)
sw
s0,(t4)
addi
t2,t2,-4
blez
t2,ploop
# should be: bgez
t2, ploop
li
t2,16
ploop:
lw
t0,4(t5)
# should be: ploop:
lw
t0,0(t5)
andi
t0,t0,0b1
beqz
t0,ploop
sw
zero, 0(t5)
j
tloop
patterns: .word 0b1111111111, 0b1111111110, 0b1111110000,
0b1110000000, 0b0000000000 \\
Page 12 of 21


## Page 13

![Page 13](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_013.png)

5. Input/Output Devices and Polling.
[15 Marks]
In this question, you will write a C-language program for the DE1-SoC computer system with a Nios
V processor to classify aluminum pipes according to their length. Below we describe the full system
that brings in the (physical) pipes and the Input/Output device set up to enable the classification.
• The pipes travel on a conveyor belt which runs at a speed of 1000 cm/sec.
• The pipes travel one by one on the belt, and there is at least 50 cm of empty space between them.
• The pipes are perfectly aligned on the conveyor belt along their length.
• An optical sensor is placed above the conveyor belt, and the sensor outputs the value 1 when a
pipe is under the sensor and the value 0 when there is no pipe under the sensor. (So, as a pipe
passes under the sensor, the sensor value will switch from 0 to 1. As the end of the pipe passes
the sensor, the sensor value changes from 1 to 0.)
• The processor can read that 1-bit value of the sensor by accessing the word at address 0xFF200070,
bit number 0. All of the other bits (besides bit 0) in the word are set to 0.
• The DE1-SoC interval timer (that you used in the lab) is configured to count down continuously
from 109 (1 billion) and operates with a 100MHz (108 Hz) clock.
• Recall that the timer counts down to 0 and then resets itself to the initial value and then continues
counting down again.
• We have provided a C-language subroutine, named timercount() that returns the current
value of the full 32-bit counter as an unsigned int type. To be clear, you do not have to
write this function, it is given.
• You can assume that maximum length of a pipe is 2000cm and the minimum length 10cm. You
do not need to check they they are within these limits.
The goal of the C-language program you are to write is to determine which of the following categories
each pipe is in, and based on the category, to control the conveyor belt system to send the pipe to
different places, as described below:
1. Category #1: Length longer than 1m. These pipes should be sent to the left-side conveyor belt.
2. Category #2: Length between 50cm and 100cm. These pipes should remain on the original
conveyor belt.
3. Category #3: Length shorter than 50cm. These pipes should be sent to the right-side conveyor
belt.
The processor can control actuators for sending a pipe to the left-side conveyor belt or the right-side
conveyor belt by writing to the word at same address as the sensor: 0xFF200070. Writing 0x10
sends the pipe to the left, writing 0x100 sends the pipe to the right, and writing 0 de-activates the
actuators and leaves the pipe on the original belt. Once the actuators are activated, they should stay so
until the program detects the next pipe (i.e. when the sensor goes from 0 to 1).
Page 13 of 21


## Page 14

![Page 14](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_014.png)

(a) Calculate how many ‘ticks’ of the timer (i.e. clock periods of the counter in the timer) corre-
[3 Marks]
spond to the each of the quantities below:
SOLUTION:
• timer ticks per cm of distance that a pipe moves on the belt: 100M(ticks/sec)/1000(cm/sec) =
108(ticks/sec)/103(cm/sec) = 105(ticks/cm)
• timer tick minimum for Class #1: 100(cm) × 105(ticks/cm) = 107(ticks)
• timer tick maximum for Class #3: 50(cm) × 105(ticks/cm) = 5 ∗106(ticks)
Define them as constants using the C macros below:
SOLUTION:
#define TICKS_MAX 1000000000 // 1B
#define TICKS_PER_SEC 100000000 // 100M (10ˆ8)
#define BELT_SPEED_CMSEC 1000 // 1000 CM/SEC (10ˆ3)
#define TICKS_PER_CM (TICKS_PER_SEC / BELT_SPEED_CMSEC) //
10ˆ8/10ˆ3
#define CLASS1_TICKS_MIN (100 * TICKS_PER_CM)
#define CLASS3_TICKS_MAX
(50 * TICKS_PER_CM)
Page 14 of 21


## Page 15

![Page 15](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_015.png)

(b) Write a C function that uses polling to classify pipes according to their length as described above,
[12 Marks]
and sets the actuators as described. The actuators should be activated immediately after the pipe
moves past the sensor and should remain active until another pipe appears under the sensor.
As mentioned above, you are given a function unsigned int timercount() that returns
an unsigned int type that is the current count value of the timer as a 32 bit unsigned integer.
Your program may use this function.
Your program can assume that the timer has already been set up and is counting in continuous
mode before your program starts.
Since the timer’s counter resets itself to TICKS MAX any time it reaches zero, your code will
have to take this into account to determine how long it took for a pipe to pass under the sensor.
Write your code on the next page. The variable ‘dr’ has been defined as a pointer to the device.
It can be used to read the sensor and control the actuators.
Page 15 of 21


## Page 16

![Page 16](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_016.png)

SOLUTION:
unsigned int timercount(); // returns the timer’s current
count value
volatile unsigned int *dr = ((unsigned int *) 0xFF200070);
void
pipe_piper() {
unsigned int start_t, end_t, total_t;
while (1) {
while (*dr == 0); // wait for pipe to appear
*dr = 0; // de-activate actuators
start_t = timecount();
while (*dr != 0); // wait for pipe to pass
end_t = timecount();
if (end_t > start_t)
// timer reset itself
total_t = start_t + (TICKS_MAX - end_t); // start_t
to 0 + MAX to end_t
else
total_t = start_t - end_t; // time elapsed end_t
smaller than start_t
if (total_t < CLASS1_TICKS_MIN) // discard left
*dr = 0x10;
else if (total_t > CLASS3_TICKS_MAX) // discard right
*dr = 0x100;
}
}
Page 16 of 21


## Page 17

![Page 17](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_017.png)

Continue answer to question 5b
Page 17 of 21


## Page 18

![Page 18](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_018.png)

The Nios V Calling Convention
This calling convention applies to assembly code that calls a subroutine. The code that is invoking the
subroutine is the termed the caller and the subroutine that is invoked is termed the callee.
1. To send parameters from the caller to the callee: The first 8 parameters to be sent to the callee are
placed into registers a0, a1 ... a7. If there are more parameters to be sent to the callee subroutine, they
must be pushed onto the stack. The caller is responsible for both pushing them onto the stack and
removing from the stack when control returns from the callee.
2. If a single word is returned by the callee to the caller, it is placed into register a0. If a second word
needs to be returned, it is place into register a1. If more than two words need to be returned, then the
callee must push that information onto the stack, and it is removed from the stack by the caller.
3. If the caller uses the temporary registers t0-t6 then it (the caller) is responsible for saving these reg-
isters. The caller must save the registers it wants to preserve on the stack. The caller would restore
those registers after the callee returns.
4. The registers s0-s11 are the responsibility of the callee. If the callee wants to use these registers, then
it must save their contents (on the stack) before changing them, use them, and then restore them from
the stack.
Page 18 of 21


## Page 19

![Page 19](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_019.png)

Extra answer space for any question on the test, if needed:
Page 19 of 21


## Page 20

![Page 20](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_020.png)

Extra answer space for any question on the test, if needed:
Page 20 of 21


## Page 21

![Page 21](https://raw.githubusercontent.com/qinshirl/SkuleBot/shifang/images/Electrical%20and%20Computer%20Engineering/page_021.png)

Extra answer space for any question on the test, if needed:
Page 21 of 21

